---
pipeline_stage: 2
pipeline_stage_name: architecture
pipeline_project: "wcp-mvp"
pipeline_started_at: "2026-02-19T09:34:01-0500"
pipeline_completed_at: "2026-02-19T09:43:42-0500"
pipeline_approved_at: "2026-02-19T09:47:42-0500"
---

# Work Context Protocol (WCP) — Architecture Proposal

> **Generated by:** Pipeline Stage 2 (Architecture)
> **Date:** 2026-02-19
> **PRD:** `prd.md`
> **Discovery Report:** N/A (greenfield project)

---

## 1. Core Architectural Decision: Protocol + Adapter

WCP is two things:

1. **A protocol** — 6 MCP tools with defined inputs, outputs, and a schema for work items
2. **A storage backend** — today: filesystem + git. Tomorrow: Linear, Jira, GitHub Issues

These are different layers. The MCP server implements the protocol. The protocol delegates to an **adapter** that handles storage. Swapping the adapter changes where data lives without changing any tool signatures or agent-facing behavior.

```
┌─────────────────────────────────────────────┐
│  MCP Server (index.ts)                      │
│  ┌───────────────────────────────────────┐   │
│  │  Tool Handlers                        │   │
│  │  wcp_list, wcp_get, wcp_create,       │   │
│  │  wcp_update, wcp_comment,             │   │
│  │  wcp_namespaces                       │   │
│  └───────────────┬───────────────────────┘   │
│                  │                           │
│                  ▼                           │
│  ┌───────────────────────────────────────┐   │
│  │  WcpAdapter (interface)               │   │
│  │  listNamespaces()                     │   │
│  │  listItems(namespace, filters)        │   │
│  │  getItem(id)                          │   │
│  │  createItem(namespace, input)         │   │
│  │  updateItem(id, changes)              │   │
│  │  addComment(id, author, body)         │   │
│  └───────────────┬───────────────────────┘   │
│                  │                           │
│        ┌─────────┼─────────┐                 │
│        ▼         ▼         ▼                 │
│   Filesystem   Linear    Jira               │
│   (MVP)        (future)  (future)            │
└─────────────────────────────────────────────┘
```

**Why this matters now (not later):** If we hardwire filesystem operations into the tool handlers (like entity-index does with SQLite), extracting the adapter later means rewriting every tool. If we define the interface now, the filesystem adapter is the same amount of code — but a Linear adapter becomes a clean addition, not a refactor.

---

## 2. Data Model

No database tables. The "data model" is the file format and the config file.

### Work Item File (e.g., `PIPE/PIPE-12.md`)

```yaml
---
id: PIPE-12                    # string, required, auto-generated
title: Add WCP MCP server      # string, required
status: in_progress             # enum, required
priority: high                  # enum, optional
type: feature                   # enum, optional
project: MVP                    # string, optional
assignee: dave                  # string, optional
parent: PIPE-1                  # string (callsign), optional
created: 2026-02-19             # ISO date, required
updated: 2026-02-19             # ISO date, required
artifacts:                      # list, optional
  - type: prd
    title: WCP PRD
    url: projects/pipe-12/prd.md
---

[Free-form markdown body — description, acceptance criteria, specs]

---

## Activity

**dave** — 2026-02-19T10:30:00-05:00
Started sketching the schema.

**pipeline-discovery** — 2026-02-19T14:00:00-05:00
Discovery complete. Found 3 existing patterns.
```

### Three Sections (Parser Must Preserve)

| Section | Delimiter | Behavior |
|---------|-----------|----------|
| **Frontmatter** | Between `---` markers at top | Structured YAML. Parsed by `gray-matter`. Modified by `wcp_update`. |
| **Body** | After frontmatter, before `---\n\n## Activity` | Free-form markdown. Returned as-is. Optionally replaced by `wcp_update` with `body` param. |
| **Activity** | From `## Activity` to end of file | Append-only. Each entry: `**{author}** — {ISO datetime}\n{body}`. Modified only by `wcp_comment`. |

The separator between body and activity is `---\n\n## Activity`. The parser splits on this. If the separator doesn't exist, the entire post-frontmatter content is the body and there is no activity log yet.

### Config File (`.wcp/config.yaml`)

```yaml
namespaces:
  PIPE:
    name: Pipeline Skills
    description: Agent pipeline framework development
    next: 4
  SN:
    name: Show Notes
    description: AI podcast summarizer
    next: 1
  OS:
    name: Operating System
    description: Personal OS tooling and improvements
    next: 1
```

### Validation Rules

| Field | Validation |
|-------|-----------|
| `status` | Must be one of: `backlog`, `todo`, `in_progress`, `in_review`, `done`, `cancelled` |
| `priority` | Must be one of: `urgent`, `high`, `medium`, `low` (or omitted) |
| `type` | Must be one of: `feature`, `bug`, `chore`, `spike` (or omitted) |
| `id` | Must match pattern `{NAMESPACE}-{N}` where namespace exists in config |
| `parent` | If provided, must be a valid callsign (format check only — referential integrity not enforced) |
| `artifacts` | Each entry must have `type` (string), `title` (string), `url` (string) |

---

## 3. Adapter Interface

This is the core abstraction. Every storage backend implements this interface.

```typescript
// src/adapter.ts

export interface Namespace {
  key: string;           // "PIPE"
  name: string;          // "Pipeline Skills"
  description: string;   // "Agent pipeline framework development"
  itemCount: number;     // count of items in namespace
}

export interface ItemSummary {
  id: string;            // "PIPE-12"
  title: string;
  status: string;
  priority?: string;
  type?: string;
  project?: string;
  assignee?: string;
  parent?: string;
  created: string;       // ISO date
  updated: string;       // ISO date
}

export interface WorkItem extends ItemSummary {
  body: string;          // markdown between frontmatter and activity
  activity: string;      // raw markdown of ## Activity section
  artifacts: Artifact[];
}

export interface Artifact {
  type: string;
  title: string;
  url: string;
}

export interface CreateItemInput {
  title: string;
  status?: string;       // default: "backlog"
  priority?: string;
  type?: string;
  project?: string;
  assignee?: string;
  parent?: string;
  body?: string;
  artifacts?: Artifact[];
}

export interface UpdateItemInput {
  title?: string;
  status?: string;
  priority?: string;
  type?: string;
  project?: string;
  assignee?: string;
  parent?: string;
  body?: string;
  addArtifacts?: Artifact[];   // append to existing list
}

export interface ItemFilters {
  status?: string;
  priority?: string;
  type?: string;
  project?: string;
  assignee?: string;
  parent?: string;
}

export interface WcpAdapter {
  // Namespace operations
  listNamespaces(): Promise<Namespace[]>;

  // Item operations
  listItems(namespace: string, filters?: ItemFilters): Promise<ItemSummary[]>;
  getItem(id: string): Promise<WorkItem>;
  createItem(namespace: string, input: CreateItemInput): Promise<string>; // returns callsign
  updateItem(id: string, changes: UpdateItemInput): Promise<void>;
  addComment(id: string, author: string, body: string): Promise<void>;
}
```

### Why `addArtifacts` Instead of `artifacts`

PRD open question Q1 asked about append vs. replace for artifacts. The answer: `UpdateItemInput` uses `addArtifacts` (append-only) for the common agent workflow ("link this PR"). If someone needs to replace the full list, they can call `getItem`, modify the list, and call `updateItem` with the full replacement — but that's a future concern. For MVP, append-only covers every real use case.

### Why `body` Is on `UpdateItemInput`

PRD open question Q6 asked how to update the description. The answer: `body` is an optional field on `updateItem`. If provided, it replaces the body section. If omitted, body is untouched. This keeps the interface to 6 tools — no need for a 7th.

---

## 4. Filesystem Adapter

The MVP adapter. Reads and writes markdown files in a git repo.

```typescript
// src/adapters/filesystem.ts

export class FilesystemAdapter implements WcpAdapter {
  constructor(private dataPath: string) {}

  // Reads .wcp/config.yaml
  // Counts files in each namespace directory
  async listNamespaces(): Promise<Namespace[]> { ... }

  // Scans {namespace}/ directory
  // Parses frontmatter from each .md file (gray-matter)
  // Applies filters
  // Returns summaries (no body, no activity)
  async listItems(namespace: string, filters?: ItemFilters): Promise<ItemSummary[]> { ... }

  // Reads {namespace}/{id}.md
  // Parses into frontmatter + body + activity
  async getItem(id: string): Promise<WorkItem> { ... }

  // Reads config, increments counter, writes config
  // Writes new {namespace}/{id}.md
  // Returns callsign
  async createItem(namespace: string, input: CreateItemInput): Promise<string> { ... }

  // Reads file, modifies frontmatter (and optionally body)
  // Preserves activity section exactly
  // Updates `updated` date
  // Writes file
  async updateItem(id: string, changes: UpdateItemInput): Promise<void> { ... }

  // Reads file, appends to ## Activity section
  // Updates `updated` date in frontmatter
  // Writes file
  async addComment(id: string, author: string, body: string): Promise<void> { ... }
}
```

### File I/O Pattern

Every write operation follows the same pattern:

1. **Read** the file (or config)
2. **Parse** into structured data (gray-matter for frontmatter, string splitting for body/activity)
3. **Modify** the structured data
4. **Serialize** back to markdown (gray-matter `stringify` for frontmatter, string concatenation for body/activity)
5. **Write** the file atomically (write to temp file, rename — `fs.writeFileSync` with the full content is acceptable for MVP since single-user)

### Callsign Parsing

A callsign like `PIPE-12` is parsed into `{ namespace: "PIPE", number: 12 }`. The file path is `{dataPath}/PIPE/PIPE-12.md`. This parsing is a utility function used by `getItem`, `updateItem`, and `addComment`.

```typescript
// src/utils.ts
function parseCallsign(id: string): { namespace: string; number: number } {
  const match = id.match(/^([A-Z]+)-(\d+)$/);
  if (!match) throw new Error(`Invalid callsign: ${id}`);
  return { namespace: match[1], number: parseInt(match[2], 10) };
}
```

### Markdown Serialization

The file format has three sections that must be round-tripped faithfully:

```typescript
// src/parser.ts
import matter from "gray-matter";

interface ParsedWorkItem {
  frontmatter: Record<string, any>;
  body: string;
  activity: string;
}

function parseWorkItem(fileContent: string): ParsedWorkItem {
  const { data, content } = matter(fileContent);

  // Split content on the activity separator
  const activitySep = "---\n\n## Activity";
  const sepIndex = content.indexOf(activitySep);

  if (sepIndex === -1) {
    return {
      frontmatter: data,
      body: content.trim(),
      activity: "",
    };
  }

  return {
    frontmatter: data,
    body: content.slice(0, sepIndex).trim(),
    activity: content.slice(sepIndex + activitySep.length).trim(),
  };
}

function serializeWorkItem(item: ParsedWorkItem): string {
  const bodySection = item.body ? `\n${item.body}\n` : "";
  const activitySection = item.activity
    ? `\n---\n\n## Activity\n\n${item.activity}\n`
    : "\n---\n\n## Activity\n";

  return matter.stringify(bodySection + activitySection, item.frontmatter);
}
```

### Config Management

```typescript
// src/config.ts
import * as fs from "fs";
import * as yaml from "yaml";   // or js-yaml
import * as path from "path";

interface NamespaceConfig {
  name: string;
  description: string;
  next: number;
}

interface WcpConfig {
  namespaces: Record<string, NamespaceConfig>;
}

function readConfig(dataPath: string): WcpConfig {
  const configPath = path.join(dataPath, ".wcp", "config.yaml");
  const raw = fs.readFileSync(configPath, "utf-8");
  return yaml.parse(raw) as WcpConfig;
}

function writeConfig(dataPath: string, config: WcpConfig): void {
  const configPath = path.join(dataPath, ".wcp", "config.yaml");
  fs.writeFileSync(configPath, yaml.stringify(config), "utf-8");
}
```

Note: `gray-matter` depends on `js-yaml` internally, so we can use `js-yaml` directly for config rather than adding another dep. Alternatively, we can use the `yaml` package (more modern). Either works — pick one and use it everywhere.

---

## 5. MCP Server (Tool Registration)

Following the entity-index pattern: `McpServer` + `StdioServerTransport` + Zod schemas.

```typescript
// src/index.ts
import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
import { StdioServerTransport } from "@modelcontextprotocol/sdk/server/stdio.js";
import { z } from "zod";
import { FilesystemAdapter } from "./adapters/filesystem.js";
import type { WcpAdapter } from "./adapter.js";

const DATA_PATH = process.env.WCP_DATA_PATH
  || path.join(os.homedir(), "projects", "wcp-data");

const adapter: WcpAdapter = new FilesystemAdapter(DATA_PATH);

const server = new McpServer({
  name: "wcp",
  version: "1.0.0",
});
```

### Tool Signatures

| Tool | Parameters (Zod) | Returns |
|------|-------------------|---------|
| `wcp_namespaces` | (none) | `{ namespaces: Namespace[] }` |
| `wcp_list` | `namespace` (required), `status?`, `priority?`, `type?`, `project?`, `assignee?`, `parent?` | `{ items: ItemSummary[], count: number }` |
| `wcp_get` | `id` (required) | `{ item: WorkItem }` |
| `wcp_create` | `namespace` (required), `title` (required), `status?`, `priority?`, `type?`, `project?`, `assignee?`, `parent?`, `body?` | `{ id: string }` |
| `wcp_update` | `id` (required), `title?`, `status?`, `priority?`, `type?`, `project?`, `assignee?`, `parent?`, `body?`, `addArtifacts?` | `{ updated: true }` |
| `wcp_comment` | `id` (required), `author` (required), `body` (required) | `{ commented: true }` |

Each tool handler is a thin wrapper: validate input via Zod → call adapter method → format response as MCP text content.

```typescript
// Example: wcp_list
server.tool(
  "wcp_list",
  "List work items in a namespace, optionally filtered by status, priority, type, project, assignee, or parent.",
  {
    namespace: z.string().describe("Namespace key, e.g. 'PIPE'"),
    status: z.string().optional().describe("Filter by status"),
    priority: z.string().optional().describe("Filter by priority"),
    type: z.string().optional().describe("Filter by type"),
    project: z.string().optional().describe("Filter by project"),
    assignee: z.string().optional().describe("Filter by assignee"),
    parent: z.string().optional().describe("Filter by parent callsign"),
  },
  async ({ namespace, ...filters }) => {
    const items = await adapter.listItems(namespace, filters);
    return {
      content: [{
        type: "text" as const,
        text: JSON.stringify({ items, count: items.length }, null, 2),
      }],
    };
  }
);
```

### Error Handling

The adapter throws typed errors. The tool handlers catch them and return structured error messages (not stack traces) to the agent.

```typescript
// src/errors.ts
export class WcpError extends Error {
  constructor(public code: string, message: string) {
    super(message);
  }
}

export class NotFoundError extends WcpError {
  constructor(id: string) {
    super("NOT_FOUND", `Item ${id} not found`);
  }
}

export class NamespaceNotFoundError extends WcpError {
  constructor(ns: string) {
    super("NAMESPACE_NOT_FOUND", `Namespace ${ns} not found. Use wcp_namespaces to see available namespaces.`);
  }
}

export class ValidationError extends WcpError {
  constructor(field: string, message: string) {
    super("VALIDATION_ERROR", `Invalid ${field}: ${message}`);
  }
}
```

Tool handlers wrap adapter calls:

```typescript
try {
  const items = await adapter.listItems(namespace, filters);
  return { content: [{ type: "text", text: JSON.stringify({ items, count: items.length }, null, 2) }] };
} catch (err) {
  if (err instanceof WcpError) {
    return { content: [{ type: "text", text: JSON.stringify({ error: err.code, message: err.message }) }] };
  }
  throw err;  // unexpected errors bubble up to MCP framework
}
```

---

## 6. Module Structure

```
wcp/
├── package.json
├── tsconfig.json
├── src/
│   ├── index.ts              # MCP server setup + tool registration
│   ├── adapter.ts            # WcpAdapter interface + types
│   ├── errors.ts             # WcpError, NotFoundError, ValidationError, etc.
│   ├── parser.ts             # parseWorkItem(), serializeWorkItem()
│   ├── config.ts             # readConfig(), writeConfig()
│   ├── utils.ts              # parseCallsign(), today(), now()
│   ├── validation.ts         # validateStatus(), validatePriority(), etc.
│   └── adapters/
│       └── filesystem.ts     # FilesystemAdapter implements WcpAdapter
└── dist/                     # compiled output
```

### Why This Structure (Not Entity-Index's 3-File Structure)

Entity-index puts everything in 3 files (`index.ts`, `database.ts`, `parser.ts`) because it has one storage backend forever. WCP needs:

- **`adapter.ts`** — the interface lives alone so future adapters can import it without importing filesystem code
- **`adapters/filesystem.ts`** — the implementation is in a subdirectory so adding `adapters/linear.ts` later is obvious
- **`parser.ts`** — filesystem-specific (markdown parsing) but separated from the adapter because it's complex enough to warrant its own module and tests
- **`config.ts`** — also filesystem-specific, but separated because config management has its own concerns (counter increment atomicity, YAML serialization)
- **`errors.ts`** — shared across adapter and tool handlers
- **`validation.ts`** — shared validation logic (valid status values, callsign format, etc.)

The filesystem adapter imports `parser.ts` and `config.ts`. A future Linear adapter would import neither — it would use the Linear API directly.

---

## 7. Dependencies

```json
{
  "dependencies": {
    "@modelcontextprotocol/sdk": "^1.26.0",
    "gray-matter": "^4.0.3",
    "zod": "^3.24.0"
  },
  "devDependencies": {
    "@types/node": "^22.0.0",
    "typescript": "^5.9.0"
  }
}
```

| Dependency | Purpose | Notes |
|-----------|---------|-------|
| `@modelcontextprotocol/sdk` | MCP server framework | Same as entity-index. Provides `McpServer`, `StdioServerTransport`. |
| `gray-matter` | YAML frontmatter parsing | Parses `---\nfoo: bar\n---\nbody` into `{ data, content }`. Handles stringify for round-tripping. Includes `js-yaml` as transitive dep — use that for config.yaml too. |
| `zod` | Tool parameter validation | Already a transitive dep of `@modelcontextprotocol/sdk`. Used for tool schemas. |

**Not included:**
- `better-sqlite3` — no database
- `yaml` / `js-yaml` — `gray-matter` bundles `js-yaml`, reuse it
- Any test framework — added in implementation phase based on preference (likely `vitest`)

---

## 8. API Endpoints

N/A — WCP exposes MCP tools, not HTTP endpoints. The 6 tool signatures are defined in Section 5.

---

## 9. Backwards Compatibility

N/A — greenfield project. No existing clients, APIs, or data.

---

## 10. Security Design

### Authorization

N/A for MVP — local tool, single user, no authentication. The MCP server runs as a child process of Claude Code with the user's filesystem permissions.

### New Attack Surface

| Vector | Risk | Mitigation |
|--------|------|------------|
| Path traversal via callsign | Low | `parseCallsign` validates format `[A-Z]+-\d+`. Namespace must exist in config. File path is constructed, never user-supplied directly. |
| YAML injection via frontmatter fields | Low | `gray-matter` handles serialization. String values are quoted automatically. |
| Malformed markdown in body/activity | None | Body and activity are opaque strings — stored and returned as-is, never interpreted. |
| Large file DoS | Low | Single-user tool. No mitigation needed for MVP. |

---

## 11. Export Impact

N/A — no export features.

---

## 12. Open Questions for Human Review

| # | Question | Options | Recommendation |
|---|----------|---------|---------------|
| 1 | Should the adapter interface be sync or async? | A: Sync (`listItems(): ItemSummary[]`) — simpler for filesystem, matches entity-index pattern. / B: Async (`listItems(): Promise<ItemSummary[]>`) — required for future Linear/Jira adapters. | **B: Async.** The filesystem adapter can just `return` (auto-wrapped in Promise). But a Linear adapter needs `await fetch(...)`. Making it async now avoids rewriting every call site later. Cost is negligible. |
| 2 | YAML library for config.yaml | A: Use `js-yaml` (bundled with gray-matter) — no extra dep. / B: Use `yaml` package — more modern API, better TypeScript types. | **A: `js-yaml`** — already in the dependency tree via gray-matter. One less dep. API is sufficient for our needs. |
| 3 | Should `wcp_list` default-sort by `updated` descending? | A: Yes — most recently touched items first. / B: By `created` descending — newest first. / C: By callsign ascending — stable, predictable. | **A: `updated` descending.** Agents typically want to see what's active. |
| 4 | Should `wcp_create` accept `body`? | A: Yes — optional body param, set during creation. / B: No — create sets frontmatter only, use `wcp_update` to add body. | **A: Yes.** Saves a round-trip. Common pattern: agent creates an item with a description in one call. |
| 5 | Concurrency: should `createItem` use file locking for the config counter? | A: Yes — use `proper-lockfile` or advisory locks. / B: No — single-user tool, accept the race condition. | **B: No locking for MVP.** Single user, single machine. If two agents race on `wcp_create`, worst case is a duplicate callsign (which would fail on file write since the file already exists). Add locking when it becomes a real problem. |

---

## 13. Alternatives Considered

### Alternative 1: Flat Architecture (No Adapter Pattern)

**Description:** Follow entity-index exactly — hardwire filesystem operations into tool handlers. `index.ts` calls `parser.ts` and `config.ts` directly. No interface, no `adapters/` directory.

**Pros:**
- Simpler initial structure (3 files vs 7)
- No interface indirection
- Faster to build

**Cons:**
- Adding a Linear adapter later means refactoring every tool handler
- Protocol and storage are entangled — can't reason about them independently
- Contradicts the project's stated goal of being a protocol, not just a tool

**Why rejected:** WCP's explicit purpose is to be a protocol with multiple backends. The adapter interface is the project's reason for existing. Building without it means building the wrong thing.

### Alternative 2: Abstract Class Instead of Interface

**Description:** Use an abstract class `WcpAdapter` with shared validation logic, instead of a pure TypeScript interface.

**Pros:**
- Shared validation (status values, callsign format) lives in the base class
- Adapters inherit common behavior

**Cons:**
- JavaScript single inheritance limits flexibility
- Validation is better as standalone functions (reusable without inheritance)
- Abstract classes feel heavy for 6 methods

**Why rejected:** A pure interface + standalone validation functions is simpler and more flexible. Adapters can compose validation however they want.

### Alternative 3: Plugin Architecture (Dynamic Loading)

**Description:** Load adapters dynamically at runtime from config (e.g., `adapter: "filesystem"` in config.yaml, resolved via `require()`).

**Pros:**
- Could switch adapters without code changes
- Extensible by third parties

**Cons:**
- Over-engineered for MVP (single user, one adapter)
- Dynamic loading adds complexity and type-safety challenges
- Config-driven adapter selection adds a concept nobody needs yet

**Why rejected:** YAGNI. Start with a hardcoded `new FilesystemAdapter(DATA_PATH)` in `index.ts`. When a second adapter exists, we can add selection logic. Don't build the plugin system before the second plugin.

---

## 14. Architecture Decision Records

| ADR | Title | Summary |
|-----|-------|---------|
| [ADR-001](decisions/ADR-001-adapter-pattern.md) | Protocol + Adapter separation | WCP separates the 6-tool protocol interface from storage backends via an adapter pattern, enabling future Linear/Jira adapters without changing tool signatures |

---

## 15. Summary

### Files to Create

| File | Purpose |
|------|---------|
| `package.json` | Dependencies: `@modelcontextprotocol/sdk`, `gray-matter`, `zod`, TypeScript |
| `tsconfig.json` | TypeScript config (ES2022, Node16 module resolution, strict) |
| `src/index.ts` | MCP server setup, 6 tool registrations, adapter instantiation |
| `src/adapter.ts` | `WcpAdapter` interface, shared types (`WorkItem`, `ItemSummary`, `Namespace`, etc.) |
| `src/errors.ts` | `WcpError`, `NotFoundError`, `NamespaceNotFoundError`, `ValidationError` |
| `src/parser.ts` | `parseWorkItem()`, `serializeWorkItem()` — markdown round-tripping with gray-matter |
| `src/config.ts` | `readConfig()`, `writeConfig()` — YAML config management |
| `src/utils.ts` | `parseCallsign()`, `today()`, `now()` — shared utilities |
| `src/validation.ts` | Status/priority/type enum validation |
| `src/adapters/filesystem.ts` | `FilesystemAdapter` implementing `WcpAdapter` |

### Files to Modify

None — greenfield project.

### Implementation Order

1. `adapter.ts` — define the interface and types first (everything depends on this)
2. `errors.ts` — error types (used by adapter and tool handlers)
3. `validation.ts` + `utils.ts` — shared utilities
4. `parser.ts` — markdown parsing (core of the filesystem adapter)
5. `config.ts` — config management
6. `adapters/filesystem.ts` — the MVP adapter (uses parser + config)
7. `index.ts` — MCP server + tool registration (calls adapter)
8. Build config (`package.json`, `tsconfig.json`)
9. Smoke test with Claude Code

---

## Approval Checklist

> **This architecture proposal requires human review and approval before the gameplan is generated.**

### Reviewer: Dave
### Date: 2026-02-19
### Status: Approved

#### Must Verify
- [ ] Adapter interface covers all 6 tools with correct input/output types
- [ ] File format (frontmatter + body + activity) is fully specified with parsing rules
- [ ] Module structure is appropriate (not over/under-decomposed)
- [ ] Error handling strategy is clear
- [ ] Dependency choices are justified

#### Should Check
- [ ] Open questions have clear recommendations
- [ ] Alternatives considered are genuine (not strawmen)
- [ ] Implementation order makes sense (dependencies flow correctly)
- [ ] The adapter pattern isn't over-engineered for MVP while still enabling future adapters

#### Notes
[Reviewer notes, modifications requested, or rejection reasons]
